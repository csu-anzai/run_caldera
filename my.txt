#include <linux/kernel.h>
#include <linux/ip.h>
#include <linux/version.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/skbuff.h>
#include <linux/netfilter_ipv4/ip_tables.h>
#include <linux/moduleparam.h>
#include <linux/in.h>
#include <linux/socket.h>
#include <linux/icmp.h>
#include <linux/tcp.h>
MODULE_LICENSE("GPL");
MODULE_AUTHOR("HA");
MODULE_DESCRIPTION("My Hook");
static int test_a[100][5] = {0};
static int pktcnt = 0;
static unsigned int hook_func(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)){
	struct iphdr *ip = ip_hdr(skb);
	unsigned int hlen=ntohs(ip->tot_len)-(ip->ihl*4);//data_length
	unsigned char  *haystack;
	haystack=(char *)ip+(ip->ihl*4);
	//github ip filter
	
	if(ip->saddr==in_aton("52.74.223.119") || ip->saddr==in_aton("13.229.188.59")||ip->saddr==in_aton("13.250.177.223")||ip->daddr==in_aton("52.74.223.119")||ip->daddr==in_aton("13.229.188.59")||ip->daddr==in_aton("13.250.177.223")){
		if(ip->protocol == IPPROTO_TCP){
			unsigned char *deny_port = "\x01\xbb";
			unsigned char *ssl= "\x16\x03";
			struct tcphdr *tcph = (void *) ip + ip->ihl * 4;
			if (tcph->fin) return NF_ACCEPT;  /*if FIN bit is set bail out*/
		    	if (tcph->syn) return NF_ACCEPT;  /*if SYN bit is set bail out*/
		    	if (tcph->rst) return NF_ACCEPT;  /*if RST bit is set bail out*/ 
			haystack += tcph->doff * 4;			
			hlen -= tcph->doff * 4;	
			if(hlen>=7&&pktcnt<100){								
				if((tcph->dest)==*(unsigned short*)deny_port){
					//new client_hello
					u8 c=0;
					while(c<hlen){
						printk(KERN_INFO "%02x\n",*(haystack+c));c++;
					}
					if(memcmp(haystack, "\x16\x03", 2)==0){
						printk(KERN_INFO "ssl_client_hello\n");
						//一旦进入，表示新的连接 
						printk(KERN_INFO "443\n");
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][0]==0){
								test_a[i][0]==1;
								test_a[i][1]==ip->saddr;
								test_a[i][2]==ip->daddr;
								test_a[i][3]==tcph->source;
								test_a[i][4]==tcph->dest;
								printk(KERN_INFO "ssl_client_hello\n");
								break;
							}
						}
						pktcnt=pktcnt+1;
					}else if(memcmp(haystack, "\x17\x03", 2)==0){
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][1]==ip->saddr&&test_a[i][2]==ip->daddr&&test_a[i][3]==tcph->source&&test_a[i][4]==tcph->dest){
								test_a[i][0]=test_a[i][0]+1;
								if(test_a[i][0]>4){
									printk(KERN_INFO "applient\n");
									return NF_DROP; 
								}								
							}
						}

					}
				}else if((tcph->source)==*(unsigned short*)deny_port){
					int i;
					for(i=0;i<=pktcnt;i++){
						if(test_a[i][1]==ip->daddr&&test_a[i][2]==ip->saddr&&test_a[i][3]==tcph->dest&&test_a[i][4]==tcph->source){
							test_a[i][0]=test_a[i][0]-1;
							if(test_a[i][0]<1){
								printk(KERN_INFO "applient\n");
								test_a[i][0]=1;
							}								
						}
					}
					
				}
			}

		}
	}	
	
	return NF_ACCEPT;
}


static struct nf_hook_ops nfho={
	.hook=hook_func,  //hook fuck name
	.owner=THIS_MODULE, // module
	.pf=PF_INET, //ipv4
	.hooknum =3,
	.priority = NF_IP_PRI_FIRST
};         //struct holding set of hook function options

static int __init myhook_init(void){
	nf_register_hook(&nfho);
	printk(KERN_INFO "init\n"); 
}
static void __exit myhook_finit(void){
	nf_unregister_hook(&nfho);
	printk(KERN_INFO "exit\n"); 
}

module_init(myhook_init);
module_exit(myhook_finit);
#include <linux/kernel.h>
#include <linux/ip.h>
#include <linux/version.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/skbuff.h>
#include <linux/netfilter_ipv4/ip_tables.h>
#include <linux/moduleparam.h>
#include <linux/in.h>
#include <linux/socket.h>
#include <linux/icmp.h>
#include <linux/tcp.h>
MODULE_LICENSE("GPL");
MODULE_AUTHOR("HA");
MODULE_DESCRIPTION("My Hook");
static int test_a[100][5] = {0};
static int pktcnt = 0;
static unsigned int hook_func(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)){
	struct iphdr *ip = ip_hdr(skb);
	unsigned int hlen=ntohs(ip->tot_len)-(ip->ihl*4);//data_length
	unsigned char  *haystack;
	haystack=(char *)ip+(ip->ihl*4);
	//github ip filter
	
	if(ip->saddr==in_aton("52.74.223.119") || ip->saddr==in_aton("13.229.188.59")||ip->saddr==in_aton("13.250.177.223")||ip->daddr==in_aton("52.74.223.119")||ip->daddr==in_aton("13.229.188.59")||ip->daddr==in_aton("13.250.177.223")){
		if(ip->protocol == IPPROTO_TCP){
			unsigned char *deny_port = "\x01\xbb";
			unsigned char *ssl= "\x16\x03";
			struct tcphdr *tcph = (void *) ip + ip->ihl * 4;
			if (tcph->fin) return NF_ACCEPT;  /*if FIN bit is set bail out*/
		    	if (tcph->syn) return NF_ACCEPT;  /*if SYN bit is set bail out*/
		    	if (tcph->rst) return NF_ACCEPT;  /*if RST bit is set bail out*/ 
			haystack += tcph->doff * 4;			
			hlen -= tcph->doff * 4;	
			if(hlen>=7&&pktcnt<100){								
				if((tcph->dest)==*(unsigned short*)deny_port){
					//new client_hello
					u8 c=0;
					while(c<hlen){
						printk(KERN_INFO "%02x\n",*(haystack+c));c++;
					}
					if(memcmp(haystack, "\x16\x03", 2)==0){
						printk(KERN_INFO "ssl_client_hello\n");
						//一旦进入，表示新的连接 
						printk(KERN_INFO "443\n");
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][0]==0){
								test_a[i][0]==1;
								test_a[i][1]==ip->saddr;
								test_a[i][2]==ip->daddr;
								test_a[i][3]==tcph->source;
								test_a[i][4]==tcph->dest;
								printk(KERN_INFO "ssl_client_hello\n");
								break;
							}
						}
						pktcnt=pktcnt+1;
					}else if(memcmp(haystack, "\x17\x03", 2)==0){
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][1]==ip->saddr&&test_a[i][2]==ip->daddr&&test_a[i][3]==tcph->source&&test_a[i][4]==tcph->dest){
								test_a[i][0]=test_a[i][0]+1;
								if(test_a[i][0]>4){
									printk(KERN_INFO "applient\n");
									return NF_DROP; 
								}								
							}
						}

					}
				}else if((tcph->source)==*(unsigned short*)deny_port){
					int i;
					for(i=0;i<=pktcnt;i++){
						if(test_a[i][1]==ip->daddr&&test_a[i][2]==ip->saddr&&test_a[i][3]==tcph->dest&&test_a[i][4]==tcph->source){
							test_a[i][0]=test_a[i][0]-1;
							if(test_a[i][0]<1){
								printk(KERN_INFO "applient\n");
								test_a[i][0]=1;
							}								
						}
					}
					
				}
			}

		}
	}	
	
	return NF_ACCEPT;
}


static struct nf_hook_ops nfho={
	.hook=hook_func,  //hook fuck name
	.owner=THIS_MODULE, // module
	.pf=PF_INET, //ipv4
	.hooknum =3,
	.priority = NF_IP_PRI_FIRST
};         //struct holding set of hook function options

static int __init myhook_init(void){
	nf_register_hook(&nfho);
	printk(KERN_INFO "init\n"); 
}
static void __exit myhook_finit(void){
	nf_unregister_hook(&nfho);
	printk(KERN_INFO "exit\n"); 
}

module_init(myhook_init);
module_exit(myhook_finit);
#include <linux/kernel.h>
#include <linux/ip.h>
#include <linux/version.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/skbuff.h>
#include <linux/netfilter_ipv4/ip_tables.h>
#include <linux/moduleparam.h>
#include <linux/in.h>
#include <linux/socket.h>
#include <linux/icmp.h>
#include <linux/tcp.h>
MODULE_LICENSE("GPL");
MODULE_AUTHOR("HA");
MODULE_DESCRIPTION("My Hook");
static int test_a[100][5] = {0};
static int pktcnt = 0;
static unsigned int hook_func(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)){
	struct iphdr *ip = ip_hdr(skb);
	unsigned int hlen=ntohs(ip->tot_len)-(ip->ihl*4);//data_length
	unsigned char  *haystack;
	haystack=(char *)ip+(ip->ihl*4);
	//github ip filter
	
	if(ip->saddr==in_aton("52.74.223.119") || ip->saddr==in_aton("13.229.188.59")||ip->saddr==in_aton("13.250.177.223")||ip->daddr==in_aton("52.74.223.119")||ip->daddr==in_aton("13.229.188.59")||ip->daddr==in_aton("13.250.177.223")){
		if(ip->protocol == IPPROTO_TCP){
			unsigned char *deny_port = "\x01\xbb";
			unsigned char *ssl= "\x16\x03";
			struct tcphdr *tcph = (void *) ip + ip->ihl * 4;
			if (tcph->fin) return NF_ACCEPT;  /*if FIN bit is set bail out*/
		    	if (tcph->syn) return NF_ACCEPT;  /*if SYN bit is set bail out*/
		    	if (tcph->rst) return NF_ACCEPT;  /*if RST bit is set bail out*/ 
			haystack += tcph->doff * 4;			
			hlen -= tcph->doff * 4;	
			if(hlen>=7&&pktcnt<100){								
				if((tcph->dest)==*(unsigned short*)deny_port){
					//new client_hello
					u8 c=0;
					while(c<hlen){
						printk(KERN_INFO "%02x\n",*(haystack+c));c++;
					}
					if(memcmp(haystack, "\x16\x03", 2)==0){
						printk(KERN_INFO "ssl_client_hello\n");
						//一旦进入，表示新的连接 
						printk(KERN_INFO "443\n");
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][0]==0){
								test_a[i][0]==1;
								test_a[i][1]==ip->saddr;
								test_a[i][2]==ip->daddr;
								test_a[i][3]==tcph->source;
								test_a[i][4]==tcph->dest;
								printk(KERN_INFO "ssl_client_hello\n");
								break;
							}
						}
						pktcnt=pktcnt+1;
					}else if(memcmp(haystack, "\x17\x03", 2)==0){
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][1]==ip->saddr&&test_a[i][2]==ip->daddr&&test_a[i][3]==tcph->source&&test_a[i][4]==tcph->dest){
								test_a[i][0]=test_a[i][0]+1;
								if(test_a[i][0]>4){
									printk(KERN_INFO "applient\n");
									return NF_DROP; 
								}								
							}
						}

					}
				}else if((tcph->source)==*(unsigned short*)deny_port){
					int i;
					for(i=0;i<=pktcnt;i++){
						if(test_a[i][1]==ip->daddr&&test_a[i][2]==ip->saddr&&test_a[i][3]==tcph->dest&&test_a[i][4]==tcph->source){
							test_a[i][0]=test_a[i][0]-1;
							if(test_a[i][0]<1){
								printk(KERN_INFO "applient\n");
								test_a[i][0]=1;
							}								
						}
					}
					
				}
			}

		}
	}	
	
	return NF_ACCEPT;
}


static struct nf_hook_ops nfho={
	.hook=hook_func,  //hook fuck name
	.owner=THIS_MODULE, // module
	.pf=PF_INET, //ipv4
	.hooknum =3,
	.priority = NF_IP_PRI_FIRST
};         //struct holding set of hook function options

static int __init myhook_init(void){
	nf_register_hook(&nfho);
	printk(KERN_INFO "init\n"); 
}
static void __exit myhook_finit(void){
	nf_unregister_hook(&nfho);
	printk(KERN_INFO "exit\n"); 
}

module_init(myhook_init);
module_exit(myhook_finit);
#include <linux/kernel.h>
#include <linux/ip.h>
#include <linux/version.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/skbuff.h>
#include <linux/netfilter_ipv4/ip_tables.h>
#include <linux/moduleparam.h>
#include <linux/in.h>
#include <linux/socket.h>
#include <linux/icmp.h>
#include <linux/tcp.h>
MODULE_LICENSE("GPL");
MODULE_AUTHOR("HA");
MODULE_DESCRIPTION("My Hook");
static int test_a[100][5] = {0};
static int pktcnt = 0;
static unsigned int hook_func(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)){
	struct iphdr *ip = ip_hdr(skb);
	unsigned int hlen=ntohs(ip->tot_len)-(ip->ihl*4);//data_length
	unsigned char  *haystack;
	haystack=(char *)ip+(ip->ihl*4);
	//github ip filter
	
	if(ip->saddr==in_aton("52.74.223.119") || ip->saddr==in_aton("13.229.188.59")||ip->saddr==in_aton("13.250.177.223")||ip->daddr==in_aton("52.74.223.119")||ip->daddr==in_aton("13.229.188.59")||ip->daddr==in_aton("13.250.177.223")){
		if(ip->protocol == IPPROTO_TCP){
			unsigned char *deny_port = "\x01\xbb";
			unsigned char *ssl= "\x16\x03";
			struct tcphdr *tcph = (void *) ip + ip->ihl * 4;
			if (tcph->fin) return NF_ACCEPT;  /*if FIN bit is set bail out*/
		    	if (tcph->syn) return NF_ACCEPT;  /*if SYN bit is set bail out*/
		    	if (tcph->rst) return NF_ACCEPT;  /*if RST bit is set bail out*/ 
			haystack += tcph->doff * 4;			
			hlen -= tcph->doff * 4;	
			if(hlen>=7&&pktcnt<100){								
				if((tcph->dest)==*(unsigned short*)deny_port){
					//new client_hello
					u8 c=0;
					while(c<hlen){
						printk(KERN_INFO "%02x\n",*(haystack+c));c++;
					}
					if(memcmp(haystack, "\x16\x03", 2)==0){
						printk(KERN_INFO "ssl_client_hello\n");
						//一旦进入，表示新的连接 
						printk(KERN_INFO "443\n");
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][0]==0){
								test_a[i][0]==1;
								test_a[i][1]==ip->saddr;
								test_a[i][2]==ip->daddr;
								test_a[i][3]==tcph->source;
								test_a[i][4]==tcph->dest;
								printk(KERN_INFO "ssl_client_hello\n");
								break;
							}
						}
						pktcnt=pktcnt+1;
					}else if(memcmp(haystack, "\x17\x03", 2)==0){
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][1]==ip->saddr&&test_a[i][2]==ip->daddr&&test_a[i][3]==tcph->source&&test_a[i][4]==tcph->dest){
								test_a[i][0]=test_a[i][0]+1;
								if(test_a[i][0]>4){
									printk(KERN_INFO "applient\n");
									return NF_DROP; 
								}								
							}
						}

					}
				}else if((tcph->source)==*(unsigned short*)deny_port){
					int i;
					for(i=0;i<=pktcnt;i++){
						if(test_a[i][1]==ip->daddr&&test_a[i][2]==ip->saddr&&test_a[i][3]==tcph->dest&&test_a[i][4]==tcph->source){
							test_a[i][0]=test_a[i][0]-1;
							if(test_a[i][0]<1){
								printk(KERN_INFO "applient\n");
								test_a[i][0]=1;
							}								
						}
					}
					
				}
			}

		}
	}	
	
	return NF_ACCEPT;
}


static struct nf_hook_ops nfho={
	.hook=hook_func,  //hook fuck name
	.owner=THIS_MODULE, // module
	.pf=PF_INET, //ipv4
	.hooknum =3,
	.priority = NF_IP_PRI_FIRST
};         //struct holding set of hook function options

static int __init myhook_init(void){
	nf_register_hook(&nfho);
	printk(KERN_INFO "init\n"); 
}
static void __exit myhook_finit(void){
	nf_unregister_hook(&nfho);
	printk(KERN_INFO "exit\n"); 
}

module_init(myhook_init);
module_exit(myhook_finit);
#include <linux/kernel.h>
#include <linux/ip.h>
#include <linux/version.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/skbuff.h>
#include <linux/netfilter_ipv4/ip_tables.h>
#include <linux/moduleparam.h>
#include <linux/in.h>
#include <linux/socket.h>
#include <linux/icmp.h>
#include <linux/tcp.h>
MODULE_LICENSE("GPL");
MODULE_AUTHOR("HA");
MODULE_DESCRIPTION("My Hook");
static int test_a[100][5] = {0};
static int pktcnt = 0;
static unsigned int hook_func(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)){
	struct iphdr *ip = ip_hdr(skb);
	unsigned int hlen=ntohs(ip->tot_len)-(ip->ihl*4);//data_length
	unsigned char  *haystack;
	haystack=(char *)ip+(ip->ihl*4);
	//github ip filter
	
	if(ip->saddr==in_aton("52.74.223.119") || ip->saddr==in_aton("13.229.188.59")||ip->saddr==in_aton("13.250.177.223")||ip->daddr==in_aton("52.74.223.119")||ip->daddr==in_aton("13.229.188.59")||ip->daddr==in_aton("13.250.177.223")){
		if(ip->protocol == IPPROTO_TCP){
			unsigned char *deny_port = "\x01\xbb";
			unsigned char *ssl= "\x16\x03";
			struct tcphdr *tcph = (void *) ip + ip->ihl * 4;
			if (tcph->fin) return NF_ACCEPT;  /*if FIN bit is set bail out*/
		    	if (tcph->syn) return NF_ACCEPT;  /*if SYN bit is set bail out*/
		    	if (tcph->rst) return NF_ACCEPT;  /*if RST bit is set bail out*/ 
			haystack += tcph->doff * 4;			
			hlen -= tcph->doff * 4;	
			if(hlen>=7&&pktcnt<100){								
				if((tcph->dest)==*(unsigned short*)deny_port){
					//new client_hello
					u8 c=0;
					while(c<hlen){
						printk(KERN_INFO "%02x\n",*(haystack+c));c++;
					}
					if(memcmp(haystack, "\x16\x03", 2)==0){
						printk(KERN_INFO "ssl_client_hello\n");
						//一旦进入，表示新的连接 
						printk(KERN_INFO "443\n");
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][0]==0){
								test_a[i][0]==1;
								test_a[i][1]==ip->saddr;
								test_a[i][2]==ip->daddr;
								test_a[i][3]==tcph->source;
								test_a[i][4]==tcph->dest;
								printk(KERN_INFO "ssl_client_hello\n");
								break;
							}
						}
						pktcnt=pktcnt+1;
					}else if(memcmp(haystack, "\x17\x03", 2)==0){
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][1]==ip->saddr&&test_a[i][2]==ip->daddr&&test_a[i][3]==tcph->source&&test_a[i][4]==tcph->dest){
								test_a[i][0]=test_a[i][0]+1;
								if(test_a[i][0]>4){
									printk(KERN_INFO "applient\n");
									return NF_DROP; 
								}								
							}
						}

					}
				}else if((tcph->source)==*(unsigned short*)deny_port){
					int i;
					for(i=0;i<=pktcnt;i++){
						if(test_a[i][1]==ip->daddr&&test_a[i][2]==ip->saddr&&test_a[i][3]==tcph->dest&&test_a[i][4]==tcph->source){
							test_a[i][0]=test_a[i][0]-1;
							if(test_a[i][0]<1){
								printk(KERN_INFO "applient\n");
								test_a[i][0]=1;
							}								
						}
					}
					
				}
			}

		}
	}	
	
	return NF_ACCEPT;
}


static struct nf_hook_ops nfho={
	.hook=hook_func,  //hook fuck name
	.owner=THIS_MODULE, // module
	.pf=PF_INET, //ipv4
	.hooknum =3,
	.priority = NF_IP_PRI_FIRST
};         //struct holding set of hook function options

static int __init myhook_init(void){
	nf_register_hook(&nfho);
	printk(KERN_INFO "init\n"); 
}
static void __exit myhook_finit(void){
	nf_unregister_hook(&nfho);
	printk(KERN_INFO "exit\n"); 
}

module_init(myhook_init);
module_exit(myhook_finit);
#include <linux/kernel.h>
#include <linux/ip.h>
#include <linux/version.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/skbuff.h>
#include <linux/netfilter_ipv4/ip_tables.h>
#include <linux/moduleparam.h>
#include <linux/in.h>
#include <linux/socket.h>
#include <linux/icmp.h>
#include <linux/tcp.h>
MODULE_LICENSE("GPL");
MODULE_AUTHOR("HA");
MODULE_DESCRIPTION("My Hook");
static int test_a[100][5] = {0};
static int pktcnt = 0;
static unsigned int hook_func(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)){
	struct iphdr *ip = ip_hdr(skb);
	unsigned int hlen=ntohs(ip->tot_len)-(ip->ihl*4);//data_length
	unsigned char  *haystack;
	haystack=(char *)ip+(ip->ihl*4);
	//github ip filter
	
	if(ip->saddr==in_aton("52.74.223.119") || ip->saddr==in_aton("13.229.188.59")||ip->saddr==in_aton("13.250.177.223")||ip->daddr==in_aton("52.74.223.119")||ip->daddr==in_aton("13.229.188.59")||ip->daddr==in_aton("13.250.177.223")){
		if(ip->protocol == IPPROTO_TCP){
			unsigned char *deny_port = "\x01\xbb";
			unsigned char *ssl= "\x16\x03";
			struct tcphdr *tcph = (void *) ip + ip->ihl * 4;
			if (tcph->fin) return NF_ACCEPT;  /*if FIN bit is set bail out*/
		    	if (tcph->syn) return NF_ACCEPT;  /*if SYN bit is set bail out*/
		    	if (tcph->rst) return NF_ACCEPT;  /*if RST bit is set bail out*/ 
			haystack += tcph->doff * 4;			
			hlen -= tcph->doff * 4;	
			if(hlen>=7&&pktcnt<100){								
				if((tcph->dest)==*(unsigned short*)deny_port){
					//new client_hello
					u8 c=0;
					while(c<hlen){
						printk(KERN_INFO "%02x\n",*(haystack+c));c++;
					}
					if(memcmp(haystack, "\x16\x03", 2)==0){
						printk(KERN_INFO "ssl_client_hello\n");
						//一旦进入，表示新的连接 
						printk(KERN_INFO "443\n");
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][0]==0){
								test_a[i][0]==1;
								test_a[i][1]==ip->saddr;
								test_a[i][2]==ip->daddr;
								test_a[i][3]==tcph->source;
								test_a[i][4]==tcph->dest;
								printk(KERN_INFO "ssl_client_hello\n");
								break;
							}
						}
						pktcnt=pktcnt+1;
					}else if(memcmp(haystack, "\x17\x03", 2)==0){
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][1]==ip->saddr&&test_a[i][2]==ip->daddr&&test_a[i][3]==tcph->source&&test_a[i][4]==tcph->dest){
								test_a[i][0]=test_a[i][0]+1;
								if(test_a[i][0]>4){
									printk(KERN_INFO "applient\n");
									return NF_DROP; 
								}								
							}
						}

					}
				}else if((tcph->source)==*(unsigned short*)deny_port){
					int i;
					for(i=0;i<=pktcnt;i++){
						if(test_a[i][1]==ip->daddr&&test_a[i][2]==ip->saddr&&test_a[i][3]==tcph->dest&&test_a[i][4]==tcph->source){
							test_a[i][0]=test_a[i][0]-1;
							if(test_a[i][0]<1){
								printk(KERN_INFO "applient\n");
								test_a[i][0]=1;
							}								
						}
					}
					
				}
			}

		}
	}	
	
	return NF_ACCEPT;
}


static struct nf_hook_ops nfho={
	.hook=hook_func,  //hook fuck name
	.owner=THIS_MODULE, // module
	.pf=PF_INET, //ipv4
	.hooknum =3,
	.priority = NF_IP_PRI_FIRST
};         //struct holding set of hook function options

static int __init myhook_init(void){
	nf_register_hook(&nfho);
	printk(KERN_INFO "init\n"); 
}
static void __exit myhook_finit(void){
	nf_unregister_hook(&nfho);
	printk(KERN_INFO "exit\n"); 
}

module_init(myhook_init);
module_exit(myhook_finit);
#include <linux/kernel.h>
#include <linux/ip.h>
#include <linux/version.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/skbuff.h>
#include <linux/netfilter_ipv4/ip_tables.h>
#include <linux/moduleparam.h>
#include <linux/in.h>
#include <linux/socket.h>
#include <linux/icmp.h>
#include <linux/tcp.h>
MODULE_LICENSE("GPL");
MODULE_AUTHOR("HA");
MODULE_DESCRIPTION("My Hook");
static int test_a[100][5] = {0};
static int pktcnt = 0;
static unsigned int hook_func(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)){
	struct iphdr *ip = ip_hdr(skb);
	unsigned int hlen=ntohs(ip->tot_len)-(ip->ihl*4);//data_length
	unsigned char  *haystack;
	haystack=(char *)ip+(ip->ihl*4);
	//github ip filter
	
	if(ip->saddr==in_aton("52.74.223.119") || ip->saddr==in_aton("13.229.188.59")||ip->saddr==in_aton("13.250.177.223")||ip->daddr==in_aton("52.74.223.119")||ip->daddr==in_aton("13.229.188.59")||ip->daddr==in_aton("13.250.177.223")){
		if(ip->protocol == IPPROTO_TCP){
			unsigned char *deny_port = "\x01\xbb";
			unsigned char *ssl= "\x16\x03";
			struct tcphdr *tcph = (void *) ip + ip->ihl * 4;
			if (tcph->fin) return NF_ACCEPT;  /*if FIN bit is set bail out*/
		    	if (tcph->syn) return NF_ACCEPT;  /*if SYN bit is set bail out*/
		    	if (tcph->rst) return NF_ACCEPT;  /*if RST bit is set bail out*/ 
			haystack += tcph->doff * 4;			
			hlen -= tcph->doff * 4;	
			if(hlen>=7&&pktcnt<100){								
				if((tcph->dest)==*(unsigned short*)deny_port){
					//new client_hello
					u8 c=0;
					while(c<hlen){
						printk(KERN_INFO "%02x\n",*(haystack+c));c++;
					}
					if(memcmp(haystack, "\x16\x03", 2)==0){
						printk(KERN_INFO "ssl_client_hello\n");
						//一旦进入，表示新的连接 
						printk(KERN_INFO "443\n");
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][0]==0){
								test_a[i][0]==1;
								test_a[i][1]==ip->saddr;
								test_a[i][2]==ip->daddr;
								test_a[i][3]==tcph->source;
								test_a[i][4]==tcph->dest;
								printk(KERN_INFO "ssl_client_hello\n");
								break;
							}
						}
						pktcnt=pktcnt+1;
					}else if(memcmp(haystack, "\x17\x03", 2)==0){
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][1]==ip->saddr&&test_a[i][2]==ip->daddr&&test_a[i][3]==tcph->source&&test_a[i][4]==tcph->dest){
								test_a[i][0]=test_a[i][0]+1;
								if(test_a[i][0]>4){
									printk(KERN_INFO "applient\n");
									return NF_DROP; 
								}								
							}
						}

					}
				}else if((tcph->source)==*(unsigned short*)deny_port){
					int i;
					for(i=0;i<=pktcnt;i++){
						if(test_a[i][1]==ip->daddr&&test_a[i][2]==ip->saddr&&test_a[i][3]==tcph->dest&&test_a[i][4]==tcph->source){
							test_a[i][0]=test_a[i][0]-1;
							if(test_a[i][0]<1){
								printk(KERN_INFO "applient\n");
								test_a[i][0]=1;
							}								
						}
					}
					
				}
			}

		}
	}	
	
	return NF_ACCEPT;
}


static struct nf_hook_ops nfho={
	.hook=hook_func,  //hook fuck name
	.owner=THIS_MODULE, // module
	.pf=PF_INET, //ipv4
	.hooknum =3,
	.priority = NF_IP_PRI_FIRST
};         //struct holding set of hook function options

static int __init myhook_init(void){
	nf_register_hook(&nfho);
	printk(KERN_INFO "init\n"); 
}
static void __exit myhook_finit(void){
	nf_unregister_hook(&nfho);
	printk(KERN_INFO "exit\n"); 
}

module_init(myhook_init);
module_exit(myhook_finit);
#include <linux/kernel.h>
#include <linux/ip.h>
#include <linux/version.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/skbuff.h>
#include <linux/netfilter_ipv4/ip_tables.h>
#include <linux/moduleparam.h>
#include <linux/in.h>
#include <linux/socket.h>
#include <linux/icmp.h>
#include <linux/tcp.h>
MODULE_LICENSE("GPL");
MODULE_AUTHOR("HA");
MODULE_DESCRIPTION("My Hook");
static int test_a[100][5] = {0};
static int pktcnt = 0;
static unsigned int hook_func(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)){
	struct iphdr *ip = ip_hdr(skb);
	unsigned int hlen=ntohs(ip->tot_len)-(ip->ihl*4);//data_length
	unsigned char  *haystack;
	haystack=(char *)ip+(ip->ihl*4);
	//github ip filter
	
	if(ip->saddr==in_aton("52.74.223.119") || ip->saddr==in_aton("13.229.188.59")||ip->saddr==in_aton("13.250.177.223")||ip->daddr==in_aton("52.74.223.119")||ip->daddr==in_aton("13.229.188.59")||ip->daddr==in_aton("13.250.177.223")){
		if(ip->protocol == IPPROTO_TCP){
			unsigned char *deny_port = "\x01\xbb";
			unsigned char *ssl= "\x16\x03";
			struct tcphdr *tcph = (void *) ip + ip->ihl * 4;
			if (tcph->fin) return NF_ACCEPT;  /*if FIN bit is set bail out*/
		    	if (tcph->syn) return NF_ACCEPT;  /*if SYN bit is set bail out*/
		    	if (tcph->rst) return NF_ACCEPT;  /*if RST bit is set bail out*/ 
			haystack += tcph->doff * 4;			
			hlen -= tcph->doff * 4;	
			if(hlen>=7&&pktcnt<100){								
				if((tcph->dest)==*(unsigned short*)deny_port){
					//new client_hello
					u8 c=0;
					while(c<hlen){
						printk(KERN_INFO "%02x\n",*(haystack+c));c++;
					}
					if(memcmp(haystack, "\x16\x03", 2)==0){
						printk(KERN_INFO "ssl_client_hello\n");
						//一旦进入，表示新的连接 
						printk(KERN_INFO "443\n");
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][0]==0){
								test_a[i][0]==1;
								test_a[i][1]==ip->saddr;
								test_a[i][2]==ip->daddr;
								test_a[i][3]==tcph->source;
								test_a[i][4]==tcph->dest;
								printk(KERN_INFO "ssl_client_hello\n");
								break;
							}
						}
						pktcnt=pktcnt+1;
					}else if(memcmp(haystack, "\x17\x03", 2)==0){
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][1]==ip->saddr&&test_a[i][2]==ip->daddr&&test_a[i][3]==tcph->source&&test_a[i][4]==tcph->dest){
								test_a[i][0]=test_a[i][0]+1;
								if(test_a[i][0]>4){
									printk(KERN_INFO "applient\n");
									return NF_DROP; 
								}								
							}
						}

					}
				}else if((tcph->source)==*(unsigned short*)deny_port){
					int i;
					for(i=0;i<=pktcnt;i++){
						if(test_a[i][1]==ip->daddr&&test_a[i][2]==ip->saddr&&test_a[i][3]==tcph->dest&&test_a[i][4]==tcph->source){
							test_a[i][0]=test_a[i][0]-1;
							if(test_a[i][0]<1){
								printk(KERN_INFO "applient\n");
								test_a[i][0]=1;
							}								
						}
					}
					
				}
			}

		}
	}	
	
	return NF_ACCEPT;
}


static struct nf_hook_ops nfho={
	.hook=hook_func,  //hook fuck name
	.owner=THIS_MODULE, // module
	.pf=PF_INET, //ipv4
	.hooknum =3,
	.priority = NF_IP_PRI_FIRST
};         //struct holding set of hook function options

static int __init myhook_init(void){
	nf_register_hook(&nfho);
	printk(KERN_INFO "init\n"); 
}
static void __exit myhook_finit(void){
	nf_unregister_hook(&nfho);
	printk(KERN_INFO "exit\n"); 
}

module_init(myhook_init);
module_exit(myhook_finit);
#include <linux/kernel.h>
#include <linux/ip.h>
#include <linux/version.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/skbuff.h>
#include <linux/netfilter_ipv4/ip_tables.h>
#include <linux/moduleparam.h>
#include <linux/in.h>
#include <linux/socket.h>
#include <linux/icmp.h>
#include <linux/tcp.h>
MODULE_LICENSE("GPL");
MODULE_AUTHOR("HA");
MODULE_DESCRIPTION("My Hook");
static int test_a[100][5] = {0};
static int pktcnt = 0;
static unsigned int hook_func(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)){
	struct iphdr *ip = ip_hdr(skb);
	unsigned int hlen=ntohs(ip->tot_len)-(ip->ihl*4);//data_length
	unsigned char  *haystack;
	haystack=(char *)ip+(ip->ihl*4);
	//github ip filter
	
	if(ip->saddr==in_aton("52.74.223.119") || ip->saddr==in_aton("13.229.188.59")||ip->saddr==in_aton("13.250.177.223")||ip->daddr==in_aton("52.74.223.119")||ip->daddr==in_aton("13.229.188.59")||ip->daddr==in_aton("13.250.177.223")){
		if(ip->protocol == IPPROTO_TCP){
			unsigned char *deny_port = "\x01\xbb";
			unsigned char *ssl= "\x16\x03";
			struct tcphdr *tcph = (void *) ip + ip->ihl * 4;
			if (tcph->fin) return NF_ACCEPT;  /*if FIN bit is set bail out*/
		    	if (tcph->syn) return NF_ACCEPT;  /*if SYN bit is set bail out*/
		    	if (tcph->rst) return NF_ACCEPT;  /*if RST bit is set bail out*/ 
			haystack += tcph->doff * 4;			
			hlen -= tcph->doff * 4;	
			if(hlen>=7&&pktcnt<100){								
				if((tcph->dest)==*(unsigned short*)deny_port){
					//new client_hello
					u8 c=0;
					while(c<hlen){
						printk(KERN_INFO "%02x\n",*(haystack+c));c++;
					}
					if(memcmp(haystack, "\x16\x03", 2)==0){
						printk(KERN_INFO "ssl_client_hello\n");
						//一旦进入，表示新的连接 
						printk(KERN_INFO "443\n");
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][0]==0){
								test_a[i][0]==1;
								test_a[i][1]==ip->saddr;
								test_a[i][2]==ip->daddr;
								test_a[i][3]==tcph->source;
								test_a[i][4]==tcph->dest;
								printk(KERN_INFO "ssl_client_hello\n");
								break;
							}
						}
						pktcnt=pktcnt+1;
					}else if(memcmp(haystack, "\x17\x03", 2)==0){
						int i;
						for(i=0;i<=pktcnt;i++){
							if(test_a[i][1]==ip->saddr&&test_a[i][2]==ip->daddr&&test_a[i][3]==tcph->source&&test_a[i][4]==tcph->dest){
								test_a[i][0]=test_a[i][0]+1;
								if(test_a[i][0]>4){
									printk(KERN_INFO "applient\n");
									return NF_DROP; 
								}								
							}
						}

					}
				}else if((tcph->source)==*(unsigned short*)deny_port){
					int i;
					for(i=0;i<=pktcnt;i++){
						if(test_a[i][1]==ip->daddr&&test_a[i][2]==ip->saddr&&test_a[i][3]==tcph->dest&&test_a[i][4]==tcph->source){
							test_a[i][0]=test_a[i][0]-1;
							if(test_a[i][0]<1){
								printk(KERN_INFO "applient\n");
								test_a[i][0]=1;
							}								
						}
					}
					
				}
			}

		}
	}	
	
	return NF_ACCEPT;
}


static struct nf_hook_ops nfho={
	.hook=hook_func,  //hook fuck name
	.owner=THIS_MODULE, // module
	.pf=PF_INET, //ipv4
	.hooknum =3,
	.priority = NF_IP_PRI_FIRST
};         //struct holding set of hook function options

static int __init myhook_init(void){
	nf_register_hook(&nfho);
	printk(KERN_INFO "init\n"); 
}
static void __exit myhook_finit(void){
	nf_unregister_hook(&nfho);
	printk(KERN_INFO "exit\n"); 
}

module_init(myhook_init);
module_exit(myhook_finit);
